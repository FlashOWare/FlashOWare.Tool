using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Runtime.CompilerServices;

namespace FlashOWare.Tool.Core.Tests.Analyzers;

[Generator(LanguageNames.CSharp)]
public sealed class InterceptorGenerator : IIncrementalGenerator
{
    private static readonly SymbolDisplayFormat? format = SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static (IncrementalGeneratorPostInitializationContext context) =>
        {
            context.AddSource("AutoGenerated.InterceptableAttribute.g.cs", """
                // <auto-generated/>

                namespace AutoGenerated;

                [global::System.AttributeUsage(global::System.AttributeTargets.Method, Inherited = false, AllowMultiple = false)]
                internal sealed class InterceptableAttribute : global::System.Attribute
                {
                }
                """);
        });

        var source = context.SyntaxProvider.CreateSyntaxProvider(
            static (SyntaxNode node, CancellationToken cancellationToken) =>
            {
                return node is InvocationExpressionSyntax;
            },
            static (GeneratorSyntaxContext context, CancellationToken cancellationToken) =>
            {
                var node = Unsafe.As<InvocationExpressionSyntax>(context.Node);
                var semanticModel = context.SemanticModel;

                if (semanticModel.GetSymbolInfo(node, cancellationToken).Symbol is IMethodSymbol method)
                {
                    INamedTypeSymbol? annotation = semanticModel.Compilation.GetTypeByMetadataName("AutoGenerated.InterceptableAttribute");

                    if (method.GetAttributes().Any((AttributeData attribute) =>
                    {
                        return attribute.AttributeClass?.Equals(annotation, SymbolEqualityComparer.Default) ?? false;
                    }))
                    {
                        if (node.Expression is MemberAccessExpressionSyntax access)
                        {
                            string name = $"{method.ContainingType.ToDisplayString(format)}.{method.ToDisplayString(format)}";

                            string filePath = GetInterceptorFilePath(node.SyntaxTree, semanticModel.Compilation);

                            TextSpan span = access.Name.Span;
                            FileLinePositionSpan lineSpan = access.SyntaxTree.GetLineSpan(span, cancellationToken);
                            LinePosition spanStart = lineSpan.StartLinePosition;
                            int line = spanStart.Line + 1;
                            int character = spanStart.Character + 1;

                            return new Model(name, filePath, line, character);
                        }
                    }
                }

                return default;
            })
            .Where(static (Model source) =>
            {
                return !source.IsDefault();
            });

        context.RegisterImplementationSourceOutput(source, static (SourceProductionContext context, Model source) =>
        {
            context.AddSource($"{source.Name}.g.cs", $$"""
                // <auto-generated/>

                namespace AutoGenerated
                {
                    using System.Runtime.CompilerServices;

                    internal static class Interceptors
                    {
                        [InterceptsLocation(@"{{source.FilePath}}", {{source.Line}}, {{source.Character}})]
                        internal static void Interceptor()
                        {
                            global::System.Console.WriteLine("Interceptor");
                        }
                    }
                }

                #pragma warning disable CS9113 // Parameter is unread.
                namespace System.Runtime.CompilerServices
                {
                    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{typeof(InterceptorGenerator).Assembly.GetName().Name}}", "{{typeof(InterceptorGenerator).Assembly.GetName().Version}}")]
                    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                    file sealed class InterceptsLocationAttribute(string filePath, int line, int character) : global::System.Attribute
                    {
                    }
                }
                #pragma warning restore CS9113 // Parameter is unread.
                """);
        });
    }

    private static string GetInterceptorFilePath(SyntaxTree tree, Compilation compilation)
    {
        return compilation.Options.SourceReferenceResolver?.NormalizePath(tree.FilePath, baseFilePath: null) ?? tree.FilePath;
    }
}

file readonly record struct Model(string Name, string FilePath, int Line, int Character)
{
    internal bool IsDefault() => Name is null && FilePath is null && Line == 0 && Character == 0;
}
